/*
Copyright 2020 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package crd

import (
	"context"
	"fmt"
	"strings"
	"sync"

	"go.uber.org/zap"
	corev1 "k8s.io/api/core/v1"
	v1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	v1beta1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/discovery"
	"k8s.io/client-go/kubernetes"

	crdreconciler "knative.dev/pkg/client/injection/apiextensions/reconciler/apiextensions/v1/customresourcedefinition"
	"knative.dev/pkg/configmap"
	"knative.dev/pkg/controller"
	"knative.dev/pkg/logging"
	"knative.dev/pkg/reconciler"
	pkgreconciler "knative.dev/pkg/reconciler"

	"knative.dev/eventing-autoscaler-keda/pkg/reconciler/keda"
	"knative.dev/eventing-autoscaler-keda/pkg/reconciler/source"
)

// newReconciledNormal makes a new reconciler event with event type Normal, and
// reason CustomResourceDefinitionReconciled.
func newReconciledNormal(namespace, name string) reconciler.Event {
	return reconciler.NewEvent(corev1.EventTypeNormal, "CustomResourceDefinitionReconciled", "CustomResourceDefinition reconciled: \"%s/%s\"", namespace, name)
}

// crdReconcileIgnored makes a new reconciler event with event type Normal, and
// reason CustomResourceDefinitionReconcileIgnored.
func crdReconcileIgnored(namespace, name string) reconciler.Event {
	return reconciler.NewEvent(corev1.EventTypeNormal, "CustomResourceDefinitionReconcileIgnored",
		"CustomResourceDefinition reconciliation ignored, KEDA autoscaling for this CRD is not supported: \"%s/%s\"", namespace, name)
}

type runningController struct {
	controller *controller.Impl
	cancel     context.CancelFunc
}

// Reconciler implements controller.Reconciler for Source CRDs resources.
type Reconciler struct {
	kubeClient kubernetes.Interface

	ogctx context.Context
	ogcmw configmap.Watcher

	// lock guards controllers
	lock sync.RWMutex

	// controllers keeps a map for GVR to dynamically created controllers.
	controllers map[schema.GroupVersionResource]runningController
}

// Check that our Reconciler implements crdreconciler.Interface
var _ crdreconciler.Interface = (*Reconciler)(nil)

// Optionally check that our Reconciler implements Finalizer
//var _ crdreconciler.Finalizer = (*Reconciler)(nil)

func (r *Reconciler) ReconcileKind(ctx context.Context, crd *v1.CustomResourceDefinition) pkgreconciler.Event {
	// The reconciliation process is as follows:
	// 	1. Resolve GVR and GVK from a particular Source CRD (i.e., those labeled with duck.knative.dev/source = "true")
	//  2. If KEDA autoscaling is not supported for resolved Source, reconciliation process is ended
	//  3. If KEDA is not installed, reconciliation process is ended
	//  4. Dynamically create a controller for it, if not present already. Such controller is in charge of reconciling
	//     duckv1.Source resources with that particular GVR

	logging.FromContext(r.ogctx).Info("In ReconcileKind for CRD")
	gvr, gvk, err := r.resolveGroupVersions(crd)
	if err != nil {
		logging.FromContext(ctx).Errorw("Error while resolving GVR and GVK", zap.String("CRD", crd.Name), zap.Error(err))
		return err
	}

	// check if KEDA autoscaling is supported for this CRD
	if !keda.SupportedCRD(*gvk) {
		return crdReconcileIgnored(crd.Namespace, crd.Name)
	}

	// check if KEDA is installed
	if err := discovery.ServerSupportsVersion(r.kubeClient.Discovery(), keda.KedaSchemeGroupVersion); err != nil {
		if strings.Contains(err.Error(), "server does not support API version") {
			logging.FromContext(ctx).Errorw("KEDA not installed, failed to check API version", zap.Any("GroupVersion", keda.KedaSchemeGroupVersion))
			return nil
		}
	}

	err = r.reconcileController(ctx, crd, gvr, gvk)
	if err != nil {
		logging.FromContext(ctx).Errorw("Error while reconciling controller", zap.String("GVR", gvr.String()), zap.String("GVK", gvk.String()), zap.Error(err))
		return err
	}

	logging.FromContext(ctx).Infow("Reconciled GVR and GVK", gvr, gvk, zap.String("CRD", crd.Name))

	return newReconciledNormal(crd.Namespace, crd.Name)
}

func (r *Reconciler) DeleteFunc(obj interface{}) {
	logging.FromContext(r.ogctx).Info("In delete function for CRD")
	if obj == nil {
		return
	}

	crdv1, ok := obj.(*v1.CustomResourceDefinition)
	if !ok {
		crdv1beta1, ok := obj.(*v1beta1.CustomResourceDefinition)
		if !ok {
			return
		}
		gvr, _, err := r.resolveGroupVersionsBeta(crdv1beta1)
		if err != nil {
			logging.FromContext(r.ogctx).Errorw("Error in delete function", zap.String("GVR", gvr.String()), zap.Error(err))
			return
		}
		r.deleteController(r.ogctx, gvr)
	} else {
		gvr, _, err := r.resolveGroupVersions(crdv1)
		if err != nil {
			logging.FromContext(r.ogctx).Errorw("Error in delete function", zap.String("GVR", gvr.String()), zap.Error(err))
			return
		}
		r.deleteController(r.ogctx, gvr)
	}
}

func (r *Reconciler) resolveGroupVersions(crd *v1.CustomResourceDefinition) (*schema.GroupVersionResource, *schema.GroupVersionKind, error) {
	var gvr *schema.GroupVersionResource
	var gvk *schema.GroupVersionKind
	for _, v := range crd.Spec.Versions {
		if !v.Served {
			continue
		}
		gvr = &schema.GroupVersionResource{
			Group:    crd.Spec.Group,
			Version:  v.Name,
			Resource: crd.Spec.Names.Plural,
		}

		gvk = &schema.GroupVersionKind{
			Group:   crd.Spec.Group,
			Version: v.Name,
			Kind:    crd.Spec.Names.Kind,
		}

	}
	if gvr == nil || gvk == nil {
		return nil, nil, fmt.Errorf("unable to find GVR or GVK for %s", crd.Name)
	}
	return gvr, gvk, nil
}

func (r *Reconciler) resolveGroupVersionsBeta(crd *v1beta1.CustomResourceDefinition) (*schema.GroupVersionResource, *schema.GroupVersionKind, error) {
	var gvr *schema.GroupVersionResource
	var gvk *schema.GroupVersionKind
	for _, v := range crd.Spec.Versions {
		if !v.Served {
			continue
		}
		gvr = &schema.GroupVersionResource{
			Group:    crd.Spec.Group,
			Version:  v.Name,
			Resource: crd.Spec.Names.Plural,
		}

		gvk = &schema.GroupVersionKind{
			Group:   crd.Spec.Group,
			Version: v.Name,
			Kind:    crd.Spec.Names.Kind,
		}

	}
	if gvr == nil || gvk == nil {
		return nil, nil, fmt.Errorf("unable to find GVR or GVK for %s", crd.Name)
	}
	return gvr, gvk, nil
}

func (r *Reconciler) deleteController(ctx context.Context, gvr *schema.GroupVersionResource) {
	logging.FromContext(r.ogctx).Info("In deleteController for CRD")
	//r.lock.RLock()
	//logging.FromContext(ctx).Info("locked")
	_, found := r.controllers[*gvr]
	//r.lock.RUnlock()
	if found {
		//r.lock.Lock()
		logging.FromContext(ctx).Info("Locked")
		// Now that we grabbed the write lock, check that nobody deleted it already.
		rc, found := r.controllers[*gvr]
		if found {
			logging.FromContext(ctx).Infow("Stopping Source Duck Controller", zap.String("GVR", gvr.String()))
			rc.cancel()
			delete(r.controllers, *gvr)
		}
		//r.lock.Unlock()
	}
}

func (r *Reconciler) reconcileController(ctx context.Context, crd *v1.CustomResourceDefinition, gvr *schema.GroupVersionResource, gvk *schema.GroupVersionKind) error {
	logging.FromContext(r.ogctx).Info("In reconcileController for CRD")
	r.lock.RLock()
	_, found := r.controllers[*gvr]
	r.lock.RUnlock()
	if found {
		return nil
	}

	r.lock.Lock()
	defer r.lock.Unlock()
	// Now that we grabbed the write lock, check that nobody has created the controller.
	_, found = r.controllers[*gvr]
	if found {
		return nil
	}

	// Source Duck controller constructor
	sdc := source.NewController(crd.Name, *gvr, *gvk)
	if sdc == nil {
		logging.FromContext(ctx).Errorw("Source Duck Controller is nil.", zap.String("GVR", gvr.String()), zap.String("GVK", gvk.String()))
		return nil
	}

	// Source Duck controller context
	sdctx, cancel := context.WithCancel(r.ogctx)
	// Source Duck controller instantiation
	sd := sdc(sdctx, r.ogcmw)

	rc := runningController{
		controller: sd,
		cancel:     cancel,
	}
	r.controllers[*gvr] = rc

	logging.FromContext(ctx).Infow("Starting Source Duck Controller", zap.String("GVR", gvr.String()), zap.String("GVK", gvk.String()))
	go func(c *controller.Impl) {
		if c != nil {
			if err := c.Run(controller.DefaultThreadsPerController, sdctx.Done()); err != nil {
				logging.FromContext(ctx).Errorw("Unable to start Source Duck Controller", zap.String("GVR", gvr.String()), zap.String("GVK", gvk.String()))
			}
		}
	}(rc.controller)
	return nil
}
